name: Weekly Expo Build for Android

on:
  schedule:
    - cron: "0 0 * * 1" # Tous les lundis Ã  00h00 UTC
  workflow_dispatch:
    inputs:
      patch_selection:
        description: "Patchs Ã  appliquer (sÃ©parer par des virgules, ou 'all' pour tous)"
        required: false
        default: "all"
      install_new_deps:
        description: "Installer les dÃ©pendance en ignorant le fichier package-lock.json"
        type: boolean
        default: false
        required: false

jobs:
  build-android:
    runs-on: ubuntu-latest

    steps:
    # 1. â˜• Configurer Java 17
    - name: â˜• Set up Java 17
      uses: actions/setup-java@v3
      with:
        distribution: "temurin" # Distribution Temurin (privilÃ©giÃ©e)
        java-version: "17"

    # 2. ğŸ“„ RÃ©cupÃ©rer le fichier JSON des sources et patchs
    - name: ğŸ“„ Fetch Patch List
      id: fetch_patch_list
      run: |
        curl -sL -H "Cache-Control: no-cache, no-store" https://raw.githubusercontent.com/Gabriel29306/datasets/main/papillon_7_patchs.json -o patch_list.json
        echo $(cat patch_list.json)

    # 3. ğŸ—‚ï¸ Extraire les informations des sources et patchs
    - name: ğŸ—‚ï¸ Parse Sources and Patch List
      id: parse_patch_list
      run: |
        echo "Parsing sources and patch list..."
        MAIN_REPO="https://github.com/PapillonApp/Papillon.git"
        ALL_PATCHES=$(jq -r '.patchs | join(",")' patch_list.json)
        echo "MAIN_REPO=$MAIN_REPO" >> $GITHUB_ENV
        echo "ALL_PATCHES=$ALL_PATCHES" >> $GITHUB_ENV

        # Extraire les sources sous forme de paires "nom=url"
        jq -r '.source | to_entries[] | "\(.key)=\(.value)"' patch_list.json > sources.txt

    # 4. ğŸ” VÃ©rifier et choisir les patchs Ã  appliquer
    - name: ğŸ” Select Patches
      id: select_patches
      run: |
        PATCH_INPUT="${{ inputs.patch_selection }}"
        if [[ "$PATCH_INPUT" == "all" ]]; then
          SELECTED_PATCHES=$ALL_PATCHES
        else
          SELECTED_PATCHES=$PATCH_INPUT
        fi
        echo "Selected patches: $SELECTED_PATCHES"
        echo "SELECTED_PATCHES=$SELECTED_PATCHES" >> $GITHUB_ENV

    # 5. ğŸ› ï¸ Cloner le main repo
    - name: ğŸ› ï¸ Clone Main Repository
      run: |
        git clone $MAIN_REPO target-repo
        cd target-repo
        git checkout main

    # 6. ğŸ”§ Configurer Node.js
    - name: ğŸ”§ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: "lts/*" # Version de Node.js Ã  utiliser
        cache: "npm" # Activer le cache pour npm
        cache-dependency-path: target-repo/package-lock.json # Chemin vers le fichier de verrouillage des dÃ©pendances

    # 7. ğŸ‘¤ Ajout de la configuration Git
    - name: ğŸ‘¤ Configure Git User
      run: |
        git config --global user.email "github-actions@github.com"
        git config --global user.name "GitHub Actions"

    # 8. ğŸ”— Ajouter les upstreams et appliquer les patchs
    - name: ğŸ”— Add Upstreams and Merge Patches
      run: |
        cd target-repo
        # Ajouter chaque upstream depuis sources.txt
        while IFS='=' read -r NAME URL; do
          echo "Adding remote: $NAME -> $URL"
          git remote add "$NAME" "$URL"
          git fetch "$NAME"
        done < ../sources.txt

        # Appliquer les patchs
        IFS=',' read -ra PATCHES <<< "$SELECTED_PATCHES"
        for PATCH in "${PATCHES[@]}"; do
          # Extraire nom et branche (par exemple : Gabriel29306/branch-name)
          NAME=$(echo "$PATCH" | cut -d'/' -f1)
          BRANCH=$(echo "$PATCH" | cut -d'/' -f2)
          echo "Merging patch: $NAME/$BRANCH"
          git fetch "$NAME" "$BRANCH"
          git merge "$NAME/$BRANCH" -s recursive || {
            echo "Conflict detected. Forcing merge for patch $PATCH."
            git merge --abort
            git merge "$NAME/$BRANCH" -s recursive -X theirs
          }
        done

    # 9. ğŸ“¦ Installer les dÃ©pendances
    - name: ğŸ“¦ Install Dependencies
      run: |
        cd target-repo
        if [[ "${{ inputs.install_new_deps }}" == "true" ]]; then
          npm install
        else
          npm ci || npm install
        fi

    # 10. ğŸ› ï¸ Prebuild l'app avec Expo
    - name: ğŸ› ï¸ Prepare Android Build
      run: |
        cd target-repo
        npx expo prebuild -p android

    # 11. âš™ï¸ Configurer gradle.properties pour gÃ©nÃ©rer des APKs par architecture
    - name: âš™ï¸ Configure Build Gradle for Split APKs
      run: |
        sed -i "s/universalApk false/universalApk true/g" target-repo/android/app/build.gradle
        sed -i '/buildToolsVersion/d' target-repo/android/app/build.gradle
    
    # 12. ğŸ—ï¸ Configuration de Gradle pour la compilation
    - name: âš™ï¸ Configure Gradle Build Properties
      run: |
        echo "org.gradle.parallel=true" >> target-repo/android/gradle.properties
        echo "org.gradle.configureondemand=true" >> target-repo/android/gradle.properties
        echo "org.gradle.daemon=false" >> target-repo/android/gradle.properties

    # 13. ğŸ—„ï¸ Configuration du cache Gradle
    - name: ğŸ—„ï¸ Cache Gradle dependencies
      uses: actions/cache@v3
      with:
        path: |
          target-repo/android/.gradle
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('target-repo/android/gradle/wrapper/gradle-wrapper.properties', 'target-repo/android/build.gradle', 'target-repo/android/app/build.gradle') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    # 14. ğŸ•µï¸â€â™‚ï¸ RÃ©cupÃ©rer la derniÃ¨re version distante, y compris les prÃ©-releases
    - name: ğŸ•µï¸â€â™‚ï¸ Get Latest Release Version
      id: get_latest_release
      uses: actions/github-script@v6
      with:
        script: |
          try {
            // Liste des releases, incluant les prÃ©-releases
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 1 // On ne prend que la premiÃ¨re release
            });
            
            if (releases.data.length > 0) {
              const latestRelease = releases.data[0]; // La derniÃ¨re release ou prÃ©-release
              const tagVersion = parseInt(latestRelease.tag_name.replace("v", ""), 10);
              
              if (isNaN(tagVersion)) {
                console.log("Invalid tag format in latest release. Using default versionCode 100.");
                core.setOutput("versionCode", 100);
              } else {
                console.log(`Latest version code (including pre-release): ${tagVersion}`);
                core.setOutput("versionCode", tagVersion);
              }
            } else {
              console.log("No release found. Using default versionCode 100.");
              core.setOutput("versionCode", 100);
            }
          } catch (error) {
            console.log("Error fetching releases: ", error);
            console.log("Using default versionCode 100.");
            core.setOutput("versionCode", 100);
          }
    
    # 15. ğŸ”¢ IncrÃ©mentation de la version
    - name: ğŸ”¢ Increment Version Code
      run: |
        cd target-repo
        # RÃ©cupÃ©rer la derniÃ¨re versionCode Ã  partir de la sortie prÃ©cÃ©dente
        BASE_VERSION_CODE="${{ steps.get_latest_release.outputs.versionCode }}"
        echo "Base versionCode: $BASE_VERSION_CODE"
        NEW_VERSION_CODE=$((BASE_VERSION_CODE + 1))
        echo "New versionCode: $NEW_VERSION_CODE"
        # Mettre Ã  jour versionCode dans build.gradle
        sed -i "s/versionCode [0-9]*/versionCode ${NEW_VERSION_CODE}/" android/app/build.gradle
        echo "VERSION_CODE=${NEW_VERSION_CODE}" >> $GITHUB_ENV
  
    # 16. ğŸ—ï¸ Build des apks
    - name: ğŸ—ï¸ Build Release APK
      run: |
        cd target-repo/android
        ./gradlew :app:assembleRelease

    # 17. ğŸ·ï¸ Renommer les apks
    - name: ğŸ·ï¸ Rename apks
      run: |
        cd target-repo/android/app/build/outputs/apk/release/
        ls
        mv app-arm64-v8a-release.apk Papillon-arm64-v8a-release.apk
        mv app-armeabi-v7a-release.apk Papillon-armeabi-v7a-release.apk
        mv app-universal-release.apk Papillon-universal-release.apk
        mv app-x86-release.apk Papillon-x86-release.apk
        mv app-x86_64-release.apk Papillon-x86_64-release.apk

    # 18. ğŸš€ Publier les APKs dans une prÃ©version
    - name: ğŸš€ Create Pre-Release with APKs
      uses: ncipollo/release-action@v1
      with:
        tag: "${{ env.VERSION_CODE }}"
        name: "Weekly Build v${{ steps.get_latest_release.outputs.version }}"
        body: "Build automatique hebdomadaire pour Android."
        prerelease: true
        artifacts: |
          target-repo/android/app/build/outputs/apk/release/*.apk
